# 线程的所有问题

## 线程6种状态

![线程生命周期](https://raw.githubusercontent.com/hanxuanliang/PicGo/master/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg)

## 阻塞状态

一般习惯而言，把 `Blocked(被阻塞)` ` Waiting(等待)`  `Timed_waiting(计时等待)`  都称为阻塞状态。

但是对于 `Block` 被阻塞的状态而言，这个是不受个人控制的，在等锁释放的过程可能很久，可能很快。相对于 `Waiting` 或者计时等待，这个是可以由我们控制的，也是在可控时间内的。

## 相关问题

- Thread类和Object类中有哪些重要的方法？
- 为什么线程通信的方法 `wait()`  `notify()`  `notifyAll()`  被定义在Object类中？而sleep却定义在Thread类中？
- 3种方式实现生产者模式？
- `Join`  `sleep`  `wait`  期间线程的状态分别是什么？为什么？

## 问题解答

> **Thread类和Object类中的方法概览：**

| 类         | 方法名                    | 简介                           |
| ---------- | ------------------------- | ------------------------------ |
| **Thread** | sleep相关                 | 本表格的相关，指的是重载方法。 |
|            | join                      | 等待其他线程执行完毕           |
|            | yield相关                 | 放弃已经获取到的CPU资源        |
|            | currentThread             | 获取当前执行线程的引用         |
|            | start，run相关            | 启动线程相关                   |
|            | interrupt相关             | 中断线程相关                   |
|            | stop，suspend，resume相关 | 已废弃                         |
| **Object** | wait/notify/notifyAll相关 | 让线程暂时休息/唤醒            |

> **`wait  notify  notifyAll` 方法详解**

- wait在以下4种情况下才会被唤醒：
  1. 另一个线程调用这个对象的 `notify()`  且刚好被唤醒的就是本线程；
  2. 另一个线程调用这个对象的 `notifyAll()`  所有的等待线程都会被唤醒；
  3. 过了 `wait(long timeout)` 规定的超时时间，如果传入 0 就是永久等待；
  4. 线程自身调用了 `interrupt()` 。

- 特点：
  1. 这3个方法都必须先拥有 monitor 锁
  2. `notify` 只能唤醒一个，而且不受我们控制
  3. 对于持有多把锁的情况，`wait` 只能释放当前拥有的那把锁【在代码块中被synchronize修饰的】

> **生产者消费者模式**

由于两者生产或者消耗的速度不一致，这个模式产生的目的就是来解决两者相互等待，相互配合比较难。 

![生产者消费者模型](https://raw.githubusercontent.com/hanxuanliang/PicGo/master/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.jpg)

```java
class EventStorage {
    private int maxSize;
    private LinkedList<Date> storage;

    public EventStorage() {
        maxSize = 10;
        storage = new LinkedList<>();
    }
    /**
    1. 如果满了，就把当前阻塞，等待别人来唤醒我
    2. 如果没满，就添加，然后通知消费者来消费
     */
    public synchronized void put() {
        while (storage.size() == maxSize) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        storage.add(new Date());
        System.out.println("仓库里有了" + storage.size() + "个产品。");
        notify();
    }
    /**
    相同的：
    1. 如果没有产品，就把消费者阻塞
    2. 如果队列还有产品，就是消耗一个，然后通知生产者生产 
     */
    public synchronized void take() {
        while (storage.size() == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("拿到了" + storage.poll() + "，现在仓库还剩下" + storage.size());
        notify();
    }
}

public class ProducerConsumerModel {
    public static void main(String[] args) {
        EventStorage eventStorage = new EventStorage();
        Producer producer = new Producer(eventStorage);
        Consumer consumer = new Consumer(eventStorage);
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}

class Producer implements Runnable {

    private EventStorage storage;

    public Producer(
            EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            storage.put();
        }
    }
}

class Consumer implements Runnable {

    private EventStorage storage;

    public Consumer(
            EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            storage.take();
        }
    }
}
```

以上方法实现结果：并不是生产完10个【storage容量】满了才通知消费者来消费，而是不定数量的，可能是10个，也可能不到10个。生产者也是，不是消费完10个被通知开始生产。

> **实现两个线程交替打印0~100的奇偶数：**
>
> `偶线程：偶数；奇线程：奇数`

- 使用 `synchronize`：

  ```java
  public class PrintOddEvenSyn {
      /**
      1. 新建两个线程
      2. 第一个只处理偶数，第二个只处理奇数（使用位运算优化）
      3. 用synchronized来通信
       */
      private static int count;
      private static final Object lock = new Object();
      
      public static void main(String[] args) {
          new Thread(new Runnable() {
              @Override
              public void run() {
                  while (count < 100) {
                      synchronized (lock) {
                          if ((count & 1) == 0) {
                              System.out.println(Thread.currentThread().getName() + ":" + count++);
                          }
                      }
                  }
              }
          }, "偶数").start();
  
          new Thread(new Runnable() {
              @Override
              public void run() {
                  while (count < 100) {
                      synchronized (lock) {
                          if ((count & 1) == 1) {
                              System.out.println(Thread.currentThread().getName() + ":" + count++);
                          }
                      }
                  }
              }
          }, "奇数").start();
      }
  }
  ```

  满足if中的条件count就会++，但是一旦++，就绝不会满足下一次循环的if判断，`synchronize` 就会一直竞争同一把锁，但是此时也只会有一个线程满足if判断，进行 `synchronize` 里的打印和++操作。所以说当前也只有一个线程可以执行，当然也只有一个线程可以竞争到这把锁。【效率不高，只是显示上是满足要求的】

  这就完成了奇偶数的交替打印。

- `wait notify`

  ```java
  public class PrintOddEveWait {
      /**
      1. 第一个先打印的拿到锁，立即打印
      2. 打印完，自己立即休眠，然后唤醒另外一个线程打印
      3. 循环这两个操作
       */
      private static int count = 0;
      private static final Object lock = new Object();
  
      public static void main(String[] args) {
          // 偶数先打印，则先启动偶数线程
          new Thread(new TurningRunner(), "偶数").start();
          new Thread(new TurningRunner(), "奇数").start();
      }
      
      static class TurningRunner implements Runnable {
  
          @Override
          public void run() {
              while (count <= 100) {
                  synchronized (lock) {
                      // 拿到锁就打印
                      System.out.println(Thread.currentThread().getName() + ":" + count++);
                      lock.notify();
                      if (count <= 100) {
                          try {
                              // 如果任务还没结束，就让出当前的锁，并休眠
                              lock.wait();
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                      }
                  }
              }
          }
      }
  }
  ```

  